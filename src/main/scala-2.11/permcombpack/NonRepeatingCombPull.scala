package permcombpack

/**
  * Created by JanVerheul on 4/13/2017.
  *
  * The class represents a generator of combinations from a given set <domain> and a given size <genSize>
  *
  * The combinations are generated by a recursive algorithm, but provided by a stream (an iterator from which successive values can be pulled).
  *
  * The discrepancy between the recursive algorithm that pushes generated values and the iterator that allows generated values to be pulled from
  *
  * is bridged by simulating the recursive algorithm iteratively an with an explicitly kept call stack.
  *
  */
class NonRepeatingCombPull[T](domain: List[T], genSize: Int)  extends Iterable[List[T]] {

    case class StackFrame(partDomain: List[T], curSize: Int, partResult: List[T], callOrder: Int)

    class MyStack[T] {
        private var rep: List[T] = Nil
        def push(t: T) = rep = t :: rep
        def pop() = rep = rep.tail
        def top() = rep.head
        def empty() = rep.isEmpty
    }

    var hasNextVar = true
    var stack = new MyStack[StackFrame]()
    stack.push(StackFrame(domain.reverse, genSize, Nil, 2))
    var callOrder = 0

    def progress() = {
        if (stack.top.partDomain.size == stack.top.curSize) callOrder = 3
        else callOrder = 1
        if (stack.top.curSize == 0 && callOrder == 2) callOrder = 3
        do {
            if (stack.top.partDomain.isEmpty) callOrder = 3
            if (stack.top.curSize == 0 && callOrder == 2) callOrder = 3
            callOrder match {
                case 1 => {
                    stack.push(StackFrame(stack.top.partDomain.tail, stack.top.curSize, stack.top.partResult, 1))
                }
                case 2 => {
                    stack.push(StackFrame(stack.top.partDomain.tail, stack.top.curSize - 1, stack.top.partDomain.head :: stack.top.partResult, 2))
                    callOrder = 1
                }
                case 3 => {
                    callOrder = stack.top.callOrder + 1
                    stack.pop()
                    hasNextVar = !stack.empty()
                }
            }
        } while (hasNextVar && stack.top.partDomain.size != stack.top.curSize)
    }

    def iterator = new Iterator[List[T]] {
        def hasNext(): Boolean = hasNextVar
        def next(): List[T] = {
            val result = stack.top.partDomain.reverse ::: stack.top.partResult
            progress()
            result
        }
        progress()
    }
}