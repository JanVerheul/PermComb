package permcombpack

import scala.util.continuations._

/**
  * Created by JanVerheul on 4/13/2017.
  *
  * The class represents a generator of combinations from a given set <elems> and a given size <genSize>
  *
  * The combinations are generated by a recursive algorithm, but provided as a stream (an iterator from which successive values can be pulled).
  *
  * The discrepancy between the recursive algorithm that pushes generated values and the iterator that allows generated values to be pulled from
  *
  * is bridged by a construction with Scala Delimited Continuations.
  *
  */
class NonRepeatingCombCont[T](elems: List[T], genSize: Int) extends Iterable[List[T]] {

    private var hasNextVar = true
    private var state: (Unit => Unit) = null
    private var value: List[T] = Nil

    reset {
        def nonRepeatRec(elems: List[T], genSize: Int, partResult: List[T]): Unit @cpsParam[Unit, Unit] = {
            if (elems.size == genSize) provide(elems.reverse ::: partResult)
            else {
                if (!elems.isEmpty) {
                    nonRepeatRec(elems.tail, genSize, partResult)
                    if (genSize > 0) nonRepeatRec(elems.tail, genSize - 1, elems.head :: partResult)
                }
            }
        }
        if (genSize < 0) throw new IllegalArgumentException("Negative lengths not allowed in Perm.repeating...")
        if (genSize > elems.size) throw new IllegalArgumentException("Lengths over elems.size not allowed in Comb.nonRepeat...")
        nonRepeatRec(elems.reverse, genSize, Nil)
        hasNextVar = false
    }

    def provide(listT: List[T]): Unit @cpsParam[Unit, Unit] = {
        shift { k: (Unit => Unit) => { state = k; value = listT } }
    }

    override def iterator: Iterator[List[T]] = new Iterator[List[T]] {
        override def hasNext: Boolean = hasNextVar
        override def next(): List[T] = {
            val fix = value
            state()
            fix
        }
    }
}
